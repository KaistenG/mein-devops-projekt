# Der Name deiner Workflow-Pipeline, der auf GitHub angezeigt wird
name: CI/CD Pipeline

# Definiert die Ereignisse, die den Workflow auslösen
on:
  push:
    branches:
      - main  # Startet den Workflow bei jedem Push auf den 'main' Branch

# Definiert die Jobs (Schritte) des Workflows
jobs:
  build_and_deploy:
    # Der Runner-Umgebung, in der der Job ausgeführt wird (eine virtuelle Maschine)
    runs-on: ubuntu-latest

    # Definiert die Schritte innerhalb des Jobs
    steps:
      # Step 1: Code aus dem Repository auschecken
      - name: Checkout Code
        uses: actions/checkout@v4

      # Step 2: Manuell bei Docker Hub anmelden
      - name: Docker Hub Login
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
        run: echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin

      # Step 3: Docker-Image bauen und pushen
      - name: Build and Push Docker Image
        run: |
          docker build -t kaisteng/devops-test-app:${{ github.run_number }} .
          docker push kaisteng/devops-test-app:${{ github.run_number }}

      # Step 4: Deployment in Kubernetes
      - name: Deploy to Kubernetes
        # Die Umgebungsvariable KUBE_CONFIG_DATA wird aus dem Secret geladen
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG }}
        run: |
          # Speichert die Kubernetes-Konfigurationsdatei temporär
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" > $HOME/.kube/config
          
          # Führt das Kubernetes-Deployment aus
          kubectl apply -f k8s-deployment.yaml
